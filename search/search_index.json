{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Julia Devito Inversion framework (JUDI.jl) JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations. Overview This documentation provides an overview over JUDI's basic data structures and abstract operators: Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . IO : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. How to : Answers FAQs, such as \"how to set up simultaneous sources\" or \"how to manually set the computational time step\". Installation First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")' Running with Docker If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts . Configure compiler and OpenMP Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads Troubleshooting For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Home"},{"location":"#the-julia-devito-inversion-framework-judijl","text":"JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations.","title":"The Julia Devito Inversion framework (JUDI.jl)"},{"location":"#overview","text":"This documentation provides an overview over JUDI's basic data structures and abstract operators: Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . IO : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. How to : Answers FAQs, such as \"how to set up simultaneous sources\" or \"how to manually set the computational time step\".","title":"Overview"},{"location":"#installation","text":"First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")'","title":"Installation"},{"location":"#running-with-docker","text":"If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts .","title":"Running with Docker"},{"location":"#configure-compiler-and-openmp","text":"Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads","title":"Configure compiler and OpenMP"},{"location":"#troubleshooting","text":"For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Troubleshooting"},{"location":"about/","text":"Authors This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"About"},{"location":"about/#authors","text":"This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"Authors"},{"location":"abstract_vectors/","text":"Abstract JUDI vectors judiVector The class judiVector is the basic data structure for seismic shot records or seismic sources. From JUDI's perspective, both are treated the same and can be multiplied with modeling operators. Construction: In the most basic way, judiVectors are contstructed from a Geometry object (containing either source or receiver geometry) and a cell array of data: x = judiVector(geometry, data) Parameters: geometry : A Geometry object containing source or receiver geometries. data : A cell array with one cell per source location, where each cell contains a 1D/2D Julia array with either the receiver data or the source wavelet. Access fields (in-core data containers): # Access i-th shot record x.data[i] # Extract judiVector for i-th shot x1 = x[i] # Access receiver locations of i-th shot x.geometry.xloc[i] Access fields (out-of-core data containers): # Access data container of i-th shot x.data[i] # Read data from i-th shot into memory x.data[i][1].data # Access out-of-core geometry x.geometry # Load OOC geometry into memory Geometry(x.geometry) Operations: In-core judiVectors can be used like regular Julia arrays and support common operations such as: x = judiVector(geometry, data) # Size (as if all data was vectorized) size(x) # Norms norm(x) # Inner product dot(x, x) # Addition, subtraction (geometries must match) y = x + x z = x - y # Scaling \u03b1 = 2f0 y = x * \u03b1 # Concatenate y = vcat(x, x) judiWavefield Abstract vector class for wavefields. Construction: u = judiWavefield(info, dt, data) Parameters: info : An Info structure. dt : Time sampling interval of wavefield. data : Cell array with one cell per source location. Each cell contains a 3D or 4D array for a seismic wavefield. The order of dimensions is (nt, nx, nz) (2D) and (nt, nx, ny, nz) (3D), where nt is the number of time steps. Access fields: # Access wavefield from i-th shot location u.data[i] Operations: Supports some basic arithmetric operations: # Size size(u) # Norms norm(u) # Inner product dot(u, y) # Addition, subtraction v = u + u z = u - v # Absolute value abs(u) # Concatenation v = vcat(u, u) judiRHS Abstract vector class for a right-hand-side (RHS). A RHS has the size of a full wavefield, but only contains the data of the source wavelet of shot records in memory, as well as the geometry information of where the data is injected during modeling. Construction: rhs = judiRHS(info, geometry, data) A JUDI RHS can also be constructed by multplying a judiVector and the corresponding transpose of a judiProjection operator: rhs1 = Ps'*q rhs2 = Pr'*d_obs where Ps and Pr are judiProjection operators for sources and receivers respectively and q and d_obs are judiVectors with the source and receiver data. Parameters: info : An Info structure. geometry : A JUDI Geometry structure, containing the source or receiver geometry. data : A cell array with one cell per source location. Each cell contains a 1D/2D Julia array with the source or receiver data. Access fields: Accessible fields include: # Source/receiver data rhs.data # Source/receiver geometry rhs.geometry # Info structure rhs.info judiWeights Abstract vector class for extended source weights. The weights for each shot location have the dimensions of the model (namely model.n ). Construction: w = judiWeights(weights) Parameters: weights : Cell array with one cell per shot location. Each cell contains a 2D/3D Julia array with the weights for the spatially extended source. Access fields: # Access weights of i-th shot locatoin w.weights[i] Operations: Supports the same arithmetric operations as a judiVector . judiExtendedSource Abstract data vector for an extended source. This data structure is the equivalent type of judiRHS for extended source modeling. A judiExtendedSource has the dimension of the full wavefield, but only contains the 1D wavelet and the 2D/3D spatially varying weights in memory. Construction: Construction from weights and source wavelets: ex_src = judiExtendedSource(info, wavelet, weights) Construction from a judiWeights vector and a judiLRWF injection operator: ex_src = Pw'*w where Pw is a judiLRWF operator and w is a judiWeights vector. Parameters: info : An Info structure. wavelet : A cell array with one cell per source location containing a 1D Julia array with the time varying source wavelet. weights : A cell array with one cell per source location containing a 2D/3D Julia array with the spatially varying source weights. Access fields: # Access weights of i-th source location ex_src.weights[i] # Access wavelet of i-th source location ex_src.wavelet[i]","title":"Abstract vectors"},{"location":"abstract_vectors/#abstract-judi-vectors","text":"","title":"Abstract JUDI vectors"},{"location":"abstract_vectors/#judivector","text":"The class judiVector is the basic data structure for seismic shot records or seismic sources. From JUDI's perspective, both are treated the same and can be multiplied with modeling operators. Construction: In the most basic way, judiVectors are contstructed from a Geometry object (containing either source or receiver geometry) and a cell array of data: x = judiVector(geometry, data) Parameters: geometry : A Geometry object containing source or receiver geometries. data : A cell array with one cell per source location, where each cell contains a 1D/2D Julia array with either the receiver data or the source wavelet. Access fields (in-core data containers): # Access i-th shot record x.data[i] # Extract judiVector for i-th shot x1 = x[i] # Access receiver locations of i-th shot x.geometry.xloc[i] Access fields (out-of-core data containers): # Access data container of i-th shot x.data[i] # Read data from i-th shot into memory x.data[i][1].data # Access out-of-core geometry x.geometry # Load OOC geometry into memory Geometry(x.geometry) Operations: In-core judiVectors can be used like regular Julia arrays and support common operations such as: x = judiVector(geometry, data) # Size (as if all data was vectorized) size(x) # Norms norm(x) # Inner product dot(x, x) # Addition, subtraction (geometries must match) y = x + x z = x - y # Scaling \u03b1 = 2f0 y = x * \u03b1 # Concatenate y = vcat(x, x)","title":"judiVector"},{"location":"abstract_vectors/#judiwavefield","text":"Abstract vector class for wavefields. Construction: u = judiWavefield(info, dt, data) Parameters: info : An Info structure. dt : Time sampling interval of wavefield. data : Cell array with one cell per source location. Each cell contains a 3D or 4D array for a seismic wavefield. The order of dimensions is (nt, nx, nz) (2D) and (nt, nx, ny, nz) (3D), where nt is the number of time steps. Access fields: # Access wavefield from i-th shot location u.data[i] Operations: Supports some basic arithmetric operations: # Size size(u) # Norms norm(u) # Inner product dot(u, y) # Addition, subtraction v = u + u z = u - v # Absolute value abs(u) # Concatenation v = vcat(u, u)","title":"judiWavefield"},{"location":"abstract_vectors/#judirhs","text":"Abstract vector class for a right-hand-side (RHS). A RHS has the size of a full wavefield, but only contains the data of the source wavelet of shot records in memory, as well as the geometry information of where the data is injected during modeling. Construction: rhs = judiRHS(info, geometry, data) A JUDI RHS can also be constructed by multplying a judiVector and the corresponding transpose of a judiProjection operator: rhs1 = Ps'*q rhs2 = Pr'*d_obs where Ps and Pr are judiProjection operators for sources and receivers respectively and q and d_obs are judiVectors with the source and receiver data. Parameters: info : An Info structure. geometry : A JUDI Geometry structure, containing the source or receiver geometry. data : A cell array with one cell per source location. Each cell contains a 1D/2D Julia array with the source or receiver data. Access fields: Accessible fields include: # Source/receiver data rhs.data # Source/receiver geometry rhs.geometry # Info structure rhs.info","title":"judiRHS"},{"location":"abstract_vectors/#judiweights","text":"Abstract vector class for extended source weights. The weights for each shot location have the dimensions of the model (namely model.n ). Construction: w = judiWeights(weights) Parameters: weights : Cell array with one cell per shot location. Each cell contains a 2D/3D Julia array with the weights for the spatially extended source. Access fields: # Access weights of i-th shot locatoin w.weights[i] Operations: Supports the same arithmetric operations as a judiVector .","title":"judiWeights"},{"location":"abstract_vectors/#judiextendedsource","text":"Abstract data vector for an extended source. This data structure is the equivalent type of judiRHS for extended source modeling. A judiExtendedSource has the dimension of the full wavefield, but only contains the 1D wavelet and the 2D/3D spatially varying weights in memory. Construction: Construction from weights and source wavelets: ex_src = judiExtendedSource(info, wavelet, weights) Construction from a judiWeights vector and a judiLRWF injection operator: ex_src = Pw'*w where Pw is a judiLRWF operator and w is a judiWeights vector. Parameters: info : An Info structure. wavelet : A cell array with one cell per source location containing a 1D Julia array with the time varying source wavelet. weights : A cell array with one cell per source location containing a 2D/3D Julia array with the spatially varying source weights. Access fields: # Access weights of i-th source location ex_src.weights[i] # Access wavelet of i-th source location ex_src.wavelet[i]","title":"judiExtendedSource"},{"location":"data_structures/","text":"Data structures Model structure Velocity models in JUDI are defined as Model structures. Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0) Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] Access fields: # Access model model.m # Access number of grid points model.n Geometry structure JUDI's geometry structure contains the information of either the source or the receiver geometry. Each geometry object contains 6 fields: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Example of how to access fields of geometry objects: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates at first source location geometry.xloc[1] # Access first receiver location (in x) at the second source location geometry.xloc[2][1] Info structure The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure.","title":"Data structures"},{"location":"data_structures/#data-structures","text":"","title":"Data structures"},{"location":"data_structures/#model-structure","text":"Velocity models in JUDI are defined as Model structures. Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0) Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] Access fields: # Access model model.m # Access number of grid points model.n","title":"Model structure"},{"location":"data_structures/#geometry-structure","text":"JUDI's geometry structure contains the information of either the source or the receiver geometry. Each geometry object contains 6 fields: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Example of how to access fields of geometry objects: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates at first source location geometry.xloc[1] # Access first receiver location (in x) at the second source location geometry.xloc[2][1]","title":"Geometry structure"},{"location":"data_structures/#info-structure","text":"The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure.","title":"Info structure"},{"location":"how_to/","text":"Tutorials Set up simple 2D experiment Working with wavefields Extended source modeling On-the-fly DFTs Simultaneous sources","title":"How to"},{"location":"how_to/#tutorials","text":"","title":"Tutorials"},{"location":"how_to/#set-up-simple-2d-experiment","text":"","title":"Set up simple 2D experiment"},{"location":"how_to/#working-with-wavefields","text":"","title":"Working with wavefields"},{"location":"how_to/#extended-source-modeling","text":"","title":"Extended source modeling"},{"location":"how_to/#on-the-fly-dfts","text":"","title":"On-the-fly DFTs"},{"location":"how_to/#simultaneous-sources","text":"","title":"Simultaneous sources"},{"location":"io/","text":"Input/Output Reading SEG-Y files into memory Reading out-of-core SEG-Y files Reading velocity models","title":"IO"},{"location":"io/#inputoutput","text":"","title":"Input/Output"},{"location":"io/#reading-seg-y-files-into-memory","text":"","title":"Reading SEG-Y files into memory"},{"location":"io/#reading-out-of-core-seg-y-files","text":"","title":"Reading out-of-core SEG-Y files"},{"location":"io/#reading-velocity-models","text":"","title":"Reading velocity models"},{"location":"linear_operators/","text":"Linear Operators judiModeling judiJacobian judiProjection judiLRWF","title":"Linear operators"},{"location":"linear_operators/#linear-operators","text":"","title":"Linear Operators"},{"location":"linear_operators/#judimodeling","text":"","title":"judiModeling"},{"location":"linear_operators/#judijacobian","text":"","title":"judiJacobian"},{"location":"linear_operators/#judiprojection","text":"","title":"judiProjection"},{"location":"linear_operators/#judilrwf","text":"","title":"judiLRWF"}]}