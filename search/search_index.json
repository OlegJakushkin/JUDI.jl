{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Julia Devito Inversion framework (JUDI.jl) JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations. Overview This documentation provides an overview over JUDI's basic data structures and abstract operators: Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . IO : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. How to : Answers FAQs, such as \"how to set up simultaneous sources\" or \"how to manually set the computational time step\". Installation First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")' Running with Docker If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts . Configure compiler and OpenMP Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads Troubleshooting For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Home"},{"location":"#the-julia-devito-inversion-framework-judijl","text":"JUDI is a framework for large-scale seismic modeling and inversion and designed to enable rapid translations of algorithms to fast and efficient code that scales to industry-size 3D problems. Wave equations in JUDI are solved with Devito , a Python domain-specific language for automated finite-difference (FD) computations.","title":"The Julia Devito Inversion framework (JUDI.jl)"},{"location":"#overview","text":"This documentation provides an overview over JUDI's basic data structures and abstract operators: Data structures : Explains the Model , Geometry and Info data structures and how to set up acquisition geometries. Abstract vectors : Documents JUDI's abstract vector classes judiVector , judiWavefield , judiRHS , judiWeights and judiExtendedSource . Abstract operators : Lists and explains JUDI's abstract linear operators judiModeling , judiJacobian , judiProjection and judiLRWF . IO : Read SEG-Y data and set up judiVectors for shot records and sources. Read velocity models. How to : Answers FAQs, such as \"how to set up simultaneous sources\" or \"how to manually set the computational time step\".","title":"Overview"},{"location":"#installation","text":"First, install Devito using pip , or see the Devito's GitHub page for installation with Conda and further information. The current release of JUDI requires Python 3 and the current Devito version. Run all of the following commands from the (bash) terminal command line (not in the Julia REPL): pip3 install --user git+https://github.com/devitocodes/devito.git For reading and writing seismic SEG-Y data, JUDI uses the SegyIO package and matrix-free linear operators are based the Julia Operator LIbrary (JOLI): julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/SegyIO.jl\"))' julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JOLI.jl\"))' Once Devito, SegyIO and JOLI are installed, you can install JUDI as follows: julia -e 'using Pkg; Pkg.develop(PackageSpec(url=\"https://github.com/slimgroup/JUDI.jl\"))' Once you have JUDI installed, you need to point Julia's PyCall package to the Python version for which we previsouly installed Devito. To do this, copy-paste the following commands into the (bash) terminal: export PYTHON=$(which python3) julia -e 'using Pkg; Pkg.build(\"PyCall\")'","title":"Installation"},{"location":"#running-with-docker","text":"If you do not want to install JUDI, you can run JUDI as a docker image. The first possibility is to run the docker container as a Jupyter notebook: docker run -p 8888:8888 philippwitte/judi:v1.3 This command downloads the image and launches a container. You will see a link that you can copy-past to your browser to access the notebooks. Alternatively, you can run a bash session, in which you can start a regular interactive Julia session and run the example scripts. Download/start the container as a bash session with: docker run -it philippwitte/judi:v1.3 /bin/bash Inside the container, all examples are located in the directory /app/judi/examples/scripts .","title":"Running with Docker"},{"location":"#configure-compiler-and-openmp","text":"Devito uses just-in-time compilation for the underlying wave equation solves. The default compiler is intel, but can be changed to any other specified compiler such as gnu . Either run the following command from the command line or add it to your ~/.bashrc file: export DEVITO_ARCH=gnu Devito uses shared memory OpenMP parallelism for solving PDEs. OpenMP is disabled by default, but you can enable OpenMP and define the number of threads (per PDE solve) as follows: export DEVITO_LANGUAGE=openmp # Enable OpenMP. export OMP_NUM_THREADS=4 # Number of OpenMP threads","title":"Configure compiler and OpenMP"},{"location":"#troubleshooting","text":"For troubleshooting please raise an issue on the JUDI github page or contact Philipp Witte at pwitte3@gatech.edu or Mathias Louboutin at mlouboutin3@gatech.edu","title":"Troubleshooting"},{"location":"about/","text":"Authors This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"About"},{"location":"about/#authors","text":"This documentation was created by Philipp A. Witte ( pwitte3@gatech.edu ) from the Georgia Institute of Technology. People involved in the development of JUDI include: Philipp A. Witte (Georgia Institute of Technology) Mathias Louboutin (Georgia Institute of Technology) Henryk Modzelewski (The Univeristy of British Columbia) Felix J. Herrmann (Georgia Institute of Technology) The research of this project was carried out at the Seismic Laboratory for Imaging and Modeling (SLIM) at the Georgia Institute of Technology, Atlanta, USA and at the University of British Columbia (UBC), in Vancouver, Canada.","title":"Authors"},{"location":"abstract_vectors/","text":"Abstract JUDI vectors judiVector judiWavefield judiRHS judiWeights judiExtendedSource","title":"Abstract vectors"},{"location":"abstract_vectors/#abstract-judi-vectors","text":"","title":"Abstract JUDI vectors"},{"location":"abstract_vectors/#judivector","text":"","title":"judiVector"},{"location":"abstract_vectors/#judiwavefield","text":"","title":"judiWavefield"},{"location":"abstract_vectors/#judirhs","text":"","title":"judiRHS"},{"location":"abstract_vectors/#judiweights","text":"","title":"judiWeights"},{"location":"abstract_vectors/#judiextendedsource","text":"","title":"judiExtendedSource"},{"location":"data_structures/","text":"Data structures Model structure Velocity models in JUDI are defined as Model structures. Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0) Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] Access fields: # Access model model.m # Access number of grid points model.n Geometry structure JUDI's geometry structure contains the information of either the source or the receiver geometry. Each geometry object contains 6 fields: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Example of how to access fields of geometry objects: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates at first source location geometry.xloc[1] # Access first receiver location (in x) at the second source location geometry.xloc[2][1] Info structure The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure.","title":"Data structures"},{"location":"data_structures/#data-structures","text":"","title":"Data structures"},{"location":"data_structures/#model-structure","text":"Velocity models in JUDI are defined as Model structures. Model requires the following input arguments: model = Model(n, d, o, m; nb=40, rho=1f0) Parameters: n : Integer tuple with number of grid points in each dimension, e.g. n = (120, 100) (2D) or n = (120, 100, 80) (3D). The order of dimenions in all tuples is (x, z) for 2D and (x, y, z) for 3D . d : Real tuple with grid spacing in each dimension. o : Real tuple with coordinate origin (typically o = (0f0, 0f0) ). m : 2D or 3D array of the velocity model in squared slowness [s^2/km^2] . nb : Number of absorbing boundary points on each edge. Default is nb = 40 . rho : 2D or 3D array of the density in [g / cm^3] Access fields: # Access model model.m # Access number of grid points model.n","title":"Model structure"},{"location":"data_structures/#geometry-structure","text":"JUDI's geometry structure contains the information of either the source or the receiver geometry. Each geometry object contains 6 fields: geometry = Geometry(xloc, yloc, zloc; dt=[], nt=[], t=[]) Parameters: xloc : Cell array, with one cell per source location. Each cell contains a 1D Julia array with the coordinates in the horizontal x direction. Coordinates are specified as distances in meters [m] relative to the model origin. yloc : Cell array for horizontal y coordinates. For 2D, set each cell entry to 0f0 . zloc : Cell array for depth coordinates (z) at each source location. dt : Cell array with the time intervals at which the data was sampled (i.e. a shot record or source wavelet was sampled). Units in milliseconds [ms] . nt : Cell array with number of time samples. t : Cell array with the recording lengths in milliseconds [ms] . From the optional arguments, you have to pass (at least) two of dt , nt and t . The third value is automatically determined and set from the two other values. Access fields: Example of how to access fields of geometry objects: # Access cell arrays of x coordinates: geometry.xloc # Access x coordinates at first source location geometry.xloc[1] # Access first receiver location (in x) at the second source location geometry.xloc[2][1]","title":"Geometry structure"},{"location":"data_structures/#info-structure","text":"The info structure contains some basic dimensionality information that needs to be available to any type of linear operator: info = Info(n, nsrc, nt) Parameters : n : Total number of grid points in all dimensions. Given by prod(model.n) . nsrc : Number of source/shot locations in the seismic experiment. nt : Number of computational time steps. You can automatically obtain the number of computational time steps as follows: nt = get_computational_nt(src_geometry, rec_geometry, model) where src_geometry is a Geometry object with the source geometry, rec_geometry is a Geometry object with the receiver geometry and model is a Model structure.","title":"Info structure"},{"location":"how_to/","text":"Applications Reverse-time migration On-the-fly DFTs Simultaneous sources","title":"How to"},{"location":"how_to/#applications","text":"","title":"Applications"},{"location":"how_to/#reverse-time-migration","text":"","title":"Reverse-time migration"},{"location":"how_to/#on-the-fly-dfts","text":"","title":"On-the-fly DFTs"},{"location":"how_to/#simultaneous-sources","text":"","title":"Simultaneous sources"},{"location":"io/","text":"Input/Output Reading SEG-Y files into memory Reading out-of-core SEG-Y files Reading velocity models","title":"IO"},{"location":"io/#inputoutput","text":"","title":"Input/Output"},{"location":"io/#reading-seg-y-files-into-memory","text":"","title":"Reading SEG-Y files into memory"},{"location":"io/#reading-out-of-core-seg-y-files","text":"","title":"Reading out-of-core SEG-Y files"},{"location":"io/#reading-velocity-models","text":"","title":"Reading velocity models"},{"location":"linear_operators/","text":"Linear Operators judiModeling judiJacobian judiProjection judiLRWF","title":"Linear operators"},{"location":"linear_operators/#linear-operators","text":"","title":"Linear Operators"},{"location":"linear_operators/#judimodeling","text":"","title":"judiModeling"},{"location":"linear_operators/#judijacobian","text":"","title":"judiJacobian"},{"location":"linear_operators/#judiprojection","text":"","title":"judiProjection"},{"location":"linear_operators/#judilrwf","text":"","title":"judiLRWF"}]}